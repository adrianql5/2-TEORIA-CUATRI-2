
# 1.1 Introducción a la Arquitectura de Computadores y Procesadores Multinúcleo
La arquitectura de computadores es el área de la informática que estudia el diseño y la organización de los procesadores, la memoria y los sistemas de interconexión para optimizar el rendimiento de los sistemas de cómputo. En esta asignatura abordaremos:

- **Modelos de computación y Taxonomía de Flynn**
- **Paralelismo y rendimiento** (ILP, TLP, RLP, GPUs)
- **Estructuras de microprocesadores y memoria caché**
- **Segmentación de procesadores y ejecución fuera de orden**

Dado el crecimiento de la demanda de procesamiento y las limitaciones físicas del modelo tradicional basado en el aumento de frecuencia, los procesadores actuales han evolucionado hacia arquitecturas multinúcleo que explotan el paralelismo.


## 1.1.1 Taxonomía de Flynn y Modelos de Computación
Michael J. Flynn propuso una clasificación de los procesadores basada en el número de flujos de **instrucciones** y **datos** que manejan simultáneamente.

| Categoría                                      | Flujo de Instrucciones | Flujo de Datos | Descripción                                                                |
| ---------------------------------------------- | ---------------------- | -------------- | -------------------------------------------------------------------------- |
| **SISD** (Single Instruction, Single Data)     | 1                      | 1              | Computación secuencial tradicional (Ej: procesadores mononúcleo antiguos). |
| **SIMD** (Single Instruction, Multiple Data)   | 1                      | Múltiples      | Ideal para procesamiento de gráficos y cálculos vectoriales (Ej: GPUs).    |
| **MISD** (Multiple Instruction, Single Data)   | Múltiples              | 1              | Poco común, usado en sistemas tolerantes a fallos.                         |
| **MIMD** (Multiple Instruction, Multiple Data) | Múltiples              | Múltiples      | Base de los procesadores multinúcleo modernos.                             |
![[Pasted image 20250403153030.png]]

Las arquitecturas **MIMD** han permitido el desarrollo de procesadores multinúcleo, lo que ha cambiado drásticamente la forma en la que se ejecutan las aplicaciones.

## 1.1.2 Arquitecturas Multinúcleo y Paralelismo

### Arquitecturas MIMD y Procesadores Multinúcleo

Los procesadores actuales utilizan arquitecturas **MIMD**, donde múltiples núcleos ejecutan instrucciones diferentes sobre distintos conjuntos de datos.

Existen dos tipos principales de sistemas multinúcleo:

- **Memoria compartida:** Todos los núcleos acceden a la misma memoria RAM.
- **Memoria distribuida:** Cada núcleo tiene su propia memoria y se comunica con otros mediante redes de interconexión.

### Tipos de Paralelismo
Para mejorar el rendimiento, los procesadores explotan distintos tipos de **paralelismo**:

1. **Instruction-Level Parallelism (ILP):**
    - Se logra mediante técnicas como ejecución fuera de orden y segmentación.
    - Se ha alcanzado un límite en la cantidad de ILP explotable.

2. **Vector Architectures / GPUs (SIMD):**
    - Se aplican instrucciones a múltiples datos en paralelo.
    - Clave en gráficos, inteligencia artificial y simulaciones científicas.

3. **Thread-Level Parallelism (TLP):**
    - Múltiples hilos ejecutados en paralelo en distintos núcleos.
    - Programación con **OpenMP, pthreads, CUDA**.

4. **Request-Level Parallelism (RLP):**
    - Procesamiento de múltiples solicitudes en paralelo.
    - Importante en servidores y bases de datos.


Para aprovechar el paralelismo, las aplicaciones deben reestructurarse para exponer tareas paralelizables.

## 1.1.3 Arquitectura Interna de un Núcleo y Memoria Caché
Los procesadores modernos utilizan una arquitectura jerárquica de **memoria caché** para minimizar los tiempos de acceso a la memoria principal.


| Nivel de Caché                    | Capacidad Típica                      | Latencia      | Característica                         |
| --------------------------------- | ------------------------------------- | ------------- | -------------------------------------- |
| **L1 (Privada por núcleo)**       | 32 KB (Datos) + 32 KB (Instrucciones) | ~4 ciclos     | Mayor velocidad, menor tamaño.         |
| **L2 (Privada por núcleo)**       | 256 KB                                | ~12 ciclos    | Equilibrio entre latencia y capacidad. |
| **L3 (Compartida entre núcleos)** | 12MB - 32MB                           | ~26-31 ciclos | Gran capacidad, mayor latencia.        |

Los accesos a memoria principal tardan **centenas de ciclos**, por lo que si un dato no está en la caché, el procesador debe esperar, reduciendo el rendimiento.

**Imagen de un core:**
![[Pasted image 20250403154035.png]]

**Imagen de un microprocesador multinúcleo (LLC->las level caché):**
![[Pasted image 20250403154222.png]]

**Funcionamiento:**
- Al realizar una operación **Load/Store**, el procesador verifica primero en caché.
- Si el dato no está, se carga desde el siguiente nivel de caché o desde memoria RAM.
- La organización en **líneas de caché** (64B por línea) optimiza la transferencia de datos.


Los procesadores utilizan memoria virtual, lo que significa que deben traducir direcciones lógicas en direcciones físicas. Para acelerar este proceso, incorporan **buffers de traducción de direcciones (TLBs)**:

| TLB                         | Función                               |
| --------------------------- | ------------------------------------- |
| **DTLB (Data TLB)**         | Traduce direcciones de datos.         |
| **ITLB (Instruction TLB)**  | Traduce direcciones de instrucciones. |
| **STLB (Second-Level TLB)** | Cache unificada de traducción.        |

Los TLBs almacenan direcciones recientemente traducidas para evitar accesos frecuentes a la tabla de páginas, reduciendo la latencia en la gestión de memoria.

## 1.1.4 Segmentación de Procesadores y Ejecución Fuera de Orden**

### **5.1. Segmentación del Pipeline**
Un procesador moderno **divide** la ejecución de instrucciones en etapas. Esto permite procesar varias instrucciones simultáneamente.

| Etapa             | Función                                            |
| ----------------- | -------------------------------------------------- |
| **Fetch**         | Se obtienen las instrucciones de la memoria caché. |
| **Decode**        | Se decodifican las instrucciones.                  |
| **Execute**       | Se ejecutan en unidades funcionales.               |
| **Memory Access** | Se accede a la memoria si es necesario.            |
| **Write Back**    | Se escriben los resultados en los registros.       |

Cuanto más profundo es el pipeline (más etapas), más instrucciones pueden ejecutarse simultáneamente, pero **mayores son las penalizaciones en caso de fallos de predicción de saltos**.

### **5.2. Ejecución Fuera de Orden y Predicción de Saltos**

Los procesadores modernos son capaces de **reordenar instrucciones** para ejecutar primero las que no dependan de resultados previos. Sin embargo:

- Si una instrucción depende de un dato aún no calculado, el procesador **debe esperar**.
- Para mitigar esto, se usa la **predicción de saltos**, que intenta anticipar el flujo del programa.
- Si la predicción falla, el procesador debe **descartar** instrucciones y volver a empezar, lo que afecta al rendimiento.

# 1.2 Tecnologías de Fabricación y Escalamiento
## 1.2.1 Tecnología de fabricación de microprocesadores
Los microprocesadores están formados por **millones o incluso miles de millones de transistores**, que funcionan como interruptores electrónicos para procesar datos. Estos transistores están fabricados con **tecnología CMOS** (_Complementary Metal-Oxide-Semiconductor_), que permite alta eficiencia energética y escalabilidad.


## 1.2.2 ¿Qué es un nodo tecnológico?
Un **nodo tecnológico** se refiere al **tamaño mínimo de los transistores y las interconexiones** en un proceso de fabricación. Este tamaño se mide en nanómetros (nm) y define la generación de un microprocesador. Ejemplo de nodos tecnológicos utilizados en la industria:
- **45 nm** (2008)
- **32 nm** (2010)
- **22 nm** (2012)
- **14 nm** (2014)
- **7 nm** (2018)
- **5 nm** (2020)
- **3 nm** (2023)

A menor tamaño del nodo, **mayor cantidad de transistores** se pueden colocar en el mismo espacio, lo que mejora la potencia de cómputo y la eficiencia energética.

## 1.2.3 Escalamiento de las dimensiones
Cada nuevo nodo tecnológico sigue un patrón de **reducción del tamaño de los transistores**.
- Cuando se pasa de un nodo a otro, las dimensiones de los transistores y conexiones se reducen en un **factor de 0.7**.
- Como el área de un transistor es proporcional al cuadrado de sus dimensiones lineales, el área total se reduce en un **factor de 0.5**.

Ejemplo práctico:
- Un procesador fabricado en **65 nm** con un área de **2 cm²** pasaría a ocupar solo **1 cm²** en una tecnología de **45 nm**.

- Si el área del procesador **se mantiene**, esto significa que se pueden incluir **más transistores** en la nueva generación, lo que permite añadir más unidades funcionales, más memoria caché, etc.    

Sin embargo, **no todas las partes del procesador escalan igual**.
- **Memorias caché** escalan casi perfectamente (x0.5).
- **Núcleos de procesamiento** pueden escalar menos eficientemente (x0.6 o x0.7), debido a la complejidad de sus circuitos.

Esta tendencia de duplicar el número de transistores con cada nueva generación se conoce como **Ley de Moore**.


## 1.2.4 Potencia Dinámica
La **potencia dinámica** es la energía consumida cuando los transistores cambian de estado (**de 0 a 1 o de 1 a 0**). Esto ocurre cada vez que el procesador ejecuta instrucciones.

### **Fórmula de la potencia dinámica en CMOS:**
$$P_{dinámica} = \frac{1}{2} C V^2 f$$

Donde:
- **C** = Carga capacitiva
- **V** = Voltaje de alimentación
- **f** = Frecuencia de reloj
### **Factores que afectan la potencia dinámica:**
**Carga capacitiva (C):**
- Depende del **número de transistores activos** y de la **capacitancia de cables y transistores**.
- En cada nueva generación, la carga capacitiva **no escala eficientemente** (se reduce solo un **factor de 0.8**), mientras que el número de transistores **se duplica (x2)**.

**Frecuencia de reloj (f):**
- A mayor frecuencia, **más conmutaciones** por segundo → **mayor consumo energético**.
- La industria ha limitado el aumento de la frecuencia por problemas de consumo y calor.

**Voltaje de alimentación (V):**
- La potencia es **proporcional al cuadrado del voltaje**, lo que significa que **reducir V** ayuda significativamente a disminuir el consumo energético.
- Sin embargo, reducir demasiado el voltaje afecta la estabilidad del procesador.

## 1.2.5 Potencia Estática (o de fuga)
La **potencia estática** es la energía consumida **incluso cuando el procesador está inactivo**. Se debe a **corrientes de fuga** que atraviesan los transistores aunque no estén cambiando de estado.
### **Fórmula de la potencia estática en CMOS:**
$$P_{estática} = I_{fuga} \times V$$

Donde:
- **I_fuga** = Corriente de fuga
- **V** = Voltaje de alimentación

### **Factores que afectan la potencia estática:**
**Corriente de fuga (I_fuga):**
- Crece **exponencialmente** con cada nueva generación. 
- Puede representar hasta **40% de la potencia total** en algunos chips modernos.

**Número de transistores:**
- Como los transistores **se duplican** con cada generación, el consumo estático también **aumenta**.
- Especialmente problemático en **memorias caché grandes**, donde puede llegar al **50% del consumo total**.


## 1.2.6 Escalamiento de la potencia y consumo energético
Uno de los principales problemas del escalamiento es el **aumento del consumo de potencia** y la disipación de calor.
### **Factores que afectan el consumo de potencia en CMOS:**

- **Número de transistores activos** → Aumenta con cada nueva generación.
- **Frecuencia de reloj** → Cuanto más alta es la frecuencia, más rápido se ejecutan las instrucciones, pero también mayor consumo energético.
- **Voltaje de alimentación** → La potencia consumida es proporcional al **cuadrado** del voltaje.


Aunque el consumo de **cada transistor** se reduce en un **factor de 0.8** con cada nueva generación, el **doble de transistores** significa que el consumo total sigue aumentando.

Además, hay otro problema: **las corrientes de fuga**.

- Estas corrientes son pérdidas de energía que no realizan trabajo útil.
- **Aumentan exponencialmente** con cada generación tecnológica.
- Actualmente pueden representar hasta **30% del consumo total de un chip**.

### **Hot Spots y limitaciones térmicas**
- En algunas áreas del chip, la **densidad de potencia** (W/cm²) es mucho más alta, lo que genera **hot spots** o puntos calientes.
- Estos hot spots aparecen en partes del procesador que realizan cálculos intensivos, como las **unidades de ejecución de direcciones**.
- Para evitar sobrecalentamiento, se deben usar **sistemas de refrigeración avanzados**.

Un límite razonable de densidad de potencia para un sistema multiprocesador es **10 kW/m²**. Si se supera, se requieren **métodos de enfriamiento avanzados y costosos**, como refrigeración líquida o sistemas criogénicos.

## 1.2.7 Métricas de eficiencia en microprocesadores
Para evaluar el rendimiento de los microprocesadores, se utilizan métricas como:

1. **GFLOPS/Watt** → Mide la eficiencia energética del procesador en **operaciones de punto flotante por segundo por cada watt consumido**.

2. **GFLOPS/mm²** → Mide la eficiencia de cómputo por unidad de área del chip.

3. **GFLOPS/m²** → Indica la **densidad de cómputo** en un centro de datos, tomando en cuenta la refrigeración por ventilación.
  ![[Pasted image 20250403161418.png]]
### **Impacto de pequeños aumentos de consumo**
- Si un procesador tiene **muy bajo consumo (0.5 W)**, un incremento fijo de **0.1 W** puede reducir drásticamente su eficiencia energética en términos de **GFLOPS/Watt**.
- Un ejemplo es el **ARM Mote**, que pierde rendimiento al aumentar ligeramente el consumo fijo.

![[Pasted image 20250403161442.png]]

## 1.2.8 Consumo de Potencia (TDP) y Evolución Energética en Microprocesadores
### **1. Evolución del Consumo de Potencia (TDP)**
🔹 **Límite de disipación de 100-200 W**
- Más allá de este límite, los **ventiladores tradicionales no pueden disipar el calor de manera eficiente**.
- Sería necesario usar **refrigeración líquida o técnicas avanzadas** de disipación térmica, lo que aumenta los costos.
### **2. Potencia Consumida a lo Largo del Tiempo**
- **Intel 80386 (1985):** **2 W**
- **Intel Core i7 (3.3 GHz, 2020):** **130 W** 
- **Supera el límite de refrigeración por aire** (los chips modernos de 1.5 cm² no pueden disipar más calor sin métodos avanzados).

**Límite térmico:** Un **procesador más potente no siempre es mejor si genera demasiado calor**.

### **3. Técnicas para Aumentar la Eficiencia Energética**
**1. Apagado de reloj en módulos inactivos**
- Cuando una unidad no está en uso, se **detiene su reloj** para evitar consumo innecesario.
 
**2. Escalado Dinámico de Voltaje-Frecuencia (DVFS)**
- Cuando el procesador está inactivo, **reduce su frecuencia y voltaje** para ahorrar energía.
 
**3. Estados de baja potencia para memoria y almacenamiento**
- **Memorias DRAM y discos duros** pueden entrar en modo de bajo consumo cuando no se usan.

**4. Overclocking y Turbo Boost**
- **Intel Turbo Boost (desde 2008)** permite que la CPU **aumente su frecuencia hasta un 10% más** por cortos períodos.
- Para compensar el aumento de temperatura, **se apagan algunos núcleos** y se **sube la frecuencia de los núcleos activos**.
- **Límite:** No puede mantenerse por mucho tiempo debido a la temperatura.

**Conclusión:** La eficiencia energética es clave para el diseño moderno de procesadores.



## 1.2.9 Escalamiento del Retardo en Circuitos CMOS
El **retardo** en los circuitos CMOS es un factor clave en la velocidad de los microprocesadores. A medida que la **tecnología avanza** (reducción de nodo tecnológico), los transistores se hacen más pequeños, lo que **reduce el retardo** de los circuitos de manera **aproximadamente lineal**.

### **¿Cómo Escala el Retardo de los Circuitos?**

**Regla general:**
- El **retardo se reduce en un factor de 0.7** con cada nueva generación de tecnología.
- Es decir, si en una tecnología de **65 nm** un circuito tiene un retardo de **10 ps**, en **45 nm** sería aproximadamente **7 ps**.

**Expresión en términos de FO4 (Fanout-of-Four):**
- No se expresa en unidades absolutas (ps) sino en términos de **FO4**, que representa el **retardo de un inversor cargado con 4 inversores**.
- Se ha comprobado que los retardos en unidades de **FO4** **son independientes del nodo tecnológico**, lo que permite comparar circuitos de distintas generaciones.

**Ejemplo:**
- Un sumador rápido tiene un **retardo de 10 FO4**.  
- Esto significa que **su retardo es 10 veces el retardo de un inversor con carga de 4 inversores**.

### **Conversión de FO4 a Retardos Absolutos**
**Fórmula Experimental:**

$$1 FO4 = 0.2 \times T \text{ (nm)} \quad (\text{en picosegundos})$$

- **Ejemplo en tecnología de 45 nm:**
$$1 FO4 = 0.2 \times 45 = 9 ps$$
- **Ejemplo en tecnología de 65 nm:**
$$1 FO4 = 0.2 \times 65 = 13 ps$$

**Ejemplo de Cálculo de Frecuencia de Reloj:**  
Si un microprocesador tiene un **ciclo de reloj de 13 FO4**, su **frecuencia** en diferentes tecnologías es:

- **45 nm:** 
$$f = \frac{1}{13 \times 9 \text{ ps}} = 8.5 \text{ GHz}$$

- **65 nm:**
$$f = \frac{1}{13 \times 13 \text{ ps}} = 5.9 \text{ GHz}$$

🔹 **Conclusión:**  
**A menor nodo tecnológico, menor retardo y mayor frecuencia de reloj.**

---

## **3. Evolución del Reloj en Microprocesadores Intel**

📌 **Ejemplos Históricos:**

1. **Pentium II (1997):**
    
    - **Frecuencia:** **300 MHz**
        
    - **Tecnología:** **350 nm**
        
    - **Ciclo de reloj:** **47 FO4**
        
2. **Pentium 4 HyperThreading (2002):**
    
    - **Frecuencia:** **3 GHz**
        
    - **Tecnología:** **130 nm**
        
    - **Ciclo de reloj:** **12.5 FO4**
        

💡 **Observación:**

- **El Pentium 4 tenía un pipeline mucho más profundo**, lo que permitía alcanzar **mayores frecuencias**.
    
- Sin embargo, **más etapas en el pipeline pueden aumentar la latencia en ciertos tipos de instrucciones**.
    

---

## **4. Relación entre Latencia, Potencia y Área**

📌 **Regla empírica:**

Latencia3×Potencia=cte(L)\text{Latencia}^3 \times \text{Potencia} = \text{cte} (L)

- Si reducimos la **latencia a la mitad (x0.5)**, la **potencia aumenta x8**.
    
- **La constante disminuye con el avance tecnológico**, lo que significa que los chips más modernos pueden operar con menor potencia relativa.
    

📌 **Efecto de la Reducción del Voltaje en la Frecuencia y Potencia**

🔹 **Relación Voltaje-Frecuencia:**

Kf=1.45Kv−0.40K_f = 1.45 K_v - 0.40

- Si bajamos el voltaje en **x0.6**, la frecuencia **se reduce en x0.5**.
    

🔹 **Impacto en la Potencia:**

P∝Kf×Kv2P \propto K_f \times K_v^2

- **Ejemplo:** Si **K_v = 0.6** y **K_f = 0.5**, la **potencia cae en x0.2**.
    

💡 **Conclusión:**

- **Escalar el voltaje es clave para reducir el consumo energético.**
    
- **Se usa en técnicas como el escalado dinámico de voltaje para ahorrar energía en momentos de baja demanda.**
    

---

## **5. Relación entre Área y Latencia**

📌 **Regla empírica:**

Aˊrea×Latencian=cte(L)\text{Área} \times \text{Latencia}^n = \text{cte} (L)

- **Si n = 2**, reducir la latencia a **x0.5** aumenta el área en **x4**.
    

🔹 **Conclusión:**

- **Reducir la latencia exige más área**, lo que puede afectar los costos de fabricación y consumo energético.
    

---

## **6. Evolución de la Tecnología y su Impacto en el Consumo de Potencia**

📌 **Figura 12 (Procesadores Intel Xeon):**

- Cada nueva generación de tecnología **reduce el consumo de energía a igual nivel de rendimiento**.
    
- También permite **mayor rendimiento sin aumentar la potencia consumida**.
    

📌 **Figura 13 (Relación Potencia-Área-Rendimiento en 45 nm):**

- **Gráfica izquierda:** Relación **potencia vs rendimiento**.
    
    - La curva sigue una **tendencia cúbica**, indicando que aumentar el rendimiento **exige mucho más consumo de energía**.
        
- **Gráfica derecha:** Relación **área vs rendimiento**.
    
    - Sigue una **tendencia cuadrática**, indicando que aumentar el rendimiento **requiere chips más grandes**.
        

💡 **Conclusión:**

- **Las mejoras tecnológicas permiten hacer más eficientes los procesadores en consumo de energía.**
    
- **A mayor rendimiento, se paga un costo alto en consumo de potencia y área.**
    

---

## **7. Conclusión General**

📌 **Escalamiento del Retardo:**

- El **retardo de los circuitos se reduce en x0.7 por cada nodo tecnológico**.
    
- Se usa el **FO4** como referencia para medir retardos de circuitos.
    
- **Ejemplo:** **45 nm → 9 ps por FO4** | **65 nm → 13 ps por FO4**.
    

📌 **Frecuencia de Reloj:**

- **Ejemplo:** **Pentium II (1997) → 300 MHz | Pentium 4 (2002) → 3 GHz**.
    
- **Procesadores más modernos tienen pipelines más profundos para alcanzar mayores frecuencias.**
    

📌 **Relaciones Clave:**

1. **Latencia³ × Potencia = constante** (Reducir latencia aumenta consumo).
    
2. **Voltaje y frecuencia están relacionados** (Reducir voltaje disminuye la frecuencia).
    
3. **Área y latencia tienen relación cuadrática** (Reducir latencia aumenta área).
    

📌 **Evolución de Tecnologías:**

- **Los procesadores modernos usan técnicas de escalado de voltaje para ahorrar energía.**
    
- **Los nuevos nodos tecnológicos permiten más rendimiento con menor consumo.**
    
- **Cada nueva generación mejora eficiencia energética y potencia de cómputo.**
    

🚀 **Futuro:**

- Uso masivo del **escalado dinámico de voltaje**.
    
- Diseño de **arquitecturas más eficientes en consumo de energía**.
    
- **Chips 3D y transistores avanzados** para seguir mejorando la computación sin aumentar la energía consumida.




## **4. Ancho de Banda y Latencia**

📌 **Ancho de Banda:**

- **Definición:** Cantidad de trabajo que puede hacerse en un tiempo dado.
    
- **Mejoras:**
    
    - **Procesadores:** Se ha mejorado **32,000-40,000X**.
        
    - **Memoria y discos:** Se ha mejorado **300-1,200X**.
        

📌 **Latencia:**

- **Definición:** Tiempo entre que se inicia y se finaliza una operación.
    
- **Mejoras:**
    
    - **Procesadores:** Se ha reducido **50-90X**.
        
    - **Memoria y discos:** Se ha reducido **6-8X**.
        

🔹 **Problema clave:**

- **Los procesadores piden datos más rápido de lo que la memoria puede entregarlos**.
    
- **La latencia de memoria es mucho mayor que la velocidad de procesamiento**.
    

---

## **5. Ancho de Banda de Memoria y su Escalabilidad**

📌 **Tendencia histórica:**

- No siempre aumenta con cada nueva generación.
    
- Generalmente **se duplica con cada nodo tecnológico**.
    

📌 **Fórmula del Ancho de Banda Máximo (BWM):**

BWM=N×FIP×CPIcorei(bytes/s)BWM = \frac{N \times F}{IP \times CPI_{\text{corei}}} \quad (\text{bytes/s})

Donde:

- **N** = Número de núcleos.
    
- **F** = Frecuencia del procesador.
    
- **IP** = Intensidad operacional (instrucciones/byte).
    
- **CPI** = Ciclos por instrucción.
    

💡 **Conclusión:**

- **El ancho de banda debe escalar con el número de núcleos, frecuencia y eficiencia de ejecución**.
- **La latencia y la potencia están ligadas**: si una mejora en latencia aumenta la potencia consumida, puede haber un **compromiso entre rendimiento y consumo**.
