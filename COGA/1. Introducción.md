# 1.1 Historia de la Computación Gráfica
La computación gráfica surge con la necesidad de generar una salida visual en los ordenadores, lo que llevó al desarrollo de las primeras pantallas.

#### **Años 50: Los inicios**
En esta década se incorporan los tubos de rayos catódicos (TRC), utilizados en las primeras televisiones y monitores, conocidos popularmente como "pantallas con culo".  
Uno de los primeros dispositivos de interacción fueron los sistemas de radar, empleados en control aéreo. Estos sistemas, operados manualmente, resultaban tan deficientes que provocaban fatiga visual en los usuarios.  
En 1956 surge el **Sensorama**, considerado la primera aplicación de realidad virtual.  
Dos años después, en 1958, se desarrolla el primer videojuego: _Tennis for Two_.

#### **Años 60: Primeros avances**
Durante esta década aparecen los primeros videojuegos, los sistemas CAD/CAM, el ratón con rueda (aunque no óptico), el DVST y los primeros cascos de visión estereoscópica.  
Uno de los nombres clave de este período es **Ivan Sutherland**, considerado el padre de la computación gráfica moderna, por sus contribuciones tanto en hardware como en software.

#### **Años 70: Computadores personales y videojuegos**
Nacen los primeros ordenadores personales y surgen grandes empresas de software y videojuegos como **Apple, Microsoft, Atari (1972, fundada por Nolan Bushnell y Ted Dabney) y Lucasfilm Games (1979)**.  
En 1972 se lanza la **Magnavox Odyssey**, la primera videoconsola doméstica.

#### **Años 80: El concepto de escritorio y la revolución gráfica**
En esta década surgen avances clave como:
- La introducción del **concepto de escritorio (desktop)**.
- El desarrollo de los primeros **guantes de realidad virtual**.
- La tecnología **BitMap**, que más tarde impulsaría el desarrollo de la **GameBoy** y las tarjetas gráficas.
- Los primeros **efectos especiales en el cine**: _Tron_ (1982) y _Willow_ (1988), que usó por primera vez la técnica de morphing.
- La expansión de **Nintendo** en la industria del entretenimiento.

#### **Años 90: OpenGL y el auge de las tarjetas gráficas**
- En 1992 se lanza la primera versión de **OpenGL**, creada por **SGI**. Esta tecnología se usó en películas como _Terminator 2_ y en sistemas de visualización avanzada.
- **Nvidia** se funda en 1993, convirtiéndose en una de las empresas líderes en el desarrollo de tarjetas gráficas.

#### **Historia de las tarjetas gráficas**
- **1ª generación (1998):** Tarjetas como **TNT2 (Nvidia), Rage (ATI) y Voodoo3 (3dfx)**. Incorporan memoria propia para almacenar texturas.
- **2ª generación (1999-2000):** Surgen las primeras **GeForce (GeForce 256, GeForce2 de Nvidia)** y nuevas tarjetas de ATI. Introducen mejoras en transformaciones de vértices e iluminación.
- **3ª generación (2001):** Se utilizan en **PlayStation 2 y Xbox**. Son programables e incluyen soporte para **vertex shaders** y primeros **pixel shaders**. DirectX 8 introduce configurabilidad a nivel de fragmentos.
- **4ª generación (2002 en adelante):** Incorporan **fragment shaders y vertex shaders**, permitiendo programar la GPU mediante lenguajes como **C, CG (Nvidia), GLSL (OpenGL), HLSL (DirectX) y CUDA**.

# 1.2 Visión Humana
Nuestros ojos captan imágenes que atraviesan la pupila y se reflejan en la retina. Luego, el cerebro las procesa.

- El cerebro humano puede procesar entre **24 y 30 imágenes por segundo (Hz)**.
- La **persistencia de la imagen** es el tiempo que una imagen queda retenida en la retina.

# 1.3 Frames por Segundo (FPS)
En computación gráfica, la velocidad de generación de imágenes se mide en **frames por segundo (FPS)**.

- **24 FPS** es la tasa estándar del cine.
- Las televisiones antiguas operaban a **50 FPS en Europa y 60 FPS en América**, debido a la frecuencia de la electricidad.
- En videojuegos, lo ideal es mantener entre **30 y 60 FPS** para una experiencia fluida.

Si un juego se ralentiza, se pueden reducir la calidad de las texturas para mejorar la velocidad de **renderizado** y aumentar los FPS.

# 1.4 Tubos de Rayos Catódicos (TRC)
Los primeros monitores funcionaban con un **haz de electrones** que impactaba contra una pantalla recubierta de **fósforo fluorescente**, generando luz.
- La persistencia del fósforo determinaba la frecuencia mínima de refresco, generalmente **50 Hz**.
- En pantallas monocromáticas, se usaba un solo haz de electrones.
- Para lograr televisión en color, se utilizaron **tres haces de electrones**, cada uno activando un fósforo de distinto color (rojo, verde y azul).

Los TRC dominaron la industria desde su invención en **1875 por Carl Ferdinand Braun** hasta su reemplazo por pantallas LCD y LED en la década del 2000.

# 1.5 Terminales Vectoriales
Estos fueron los primeros tipos de pantallas utilizadas para visualizar gráficos en ordenadores. Funcionaban de manera diferente a las pantallas actuales. En lugar de representar la imagen como una cuadrícula de píxeles (como hacen las pantallas modernas), los terminales vectoriales trazaban líneas directamente en la pantalla siguiendo coordenadas específicas.

![[Pasted image 20250216234057.png]]

Tenía una memoria en la que se almacenaban las instrucciones del dibujo y que se comunicaba con la pantalla y la interfaz del ordenador. El operador interactúa con la interfaz, que se lo enviaba a la unidad de procesamiento de la terminal gráfica, esta le indicaba las instrucciones a la memoria, dónde se almacenaban (principalmente movimientos) y se realizaban líneas por la pantalla. El correcto funcionamiento de estos terminales depende de la complejidad del dibujo
# 1.6 Terminales Raster
Aparecen en los años 70 y reemplazan a los terminales vectoriales. Se basan en el concepto de **rasterización**, es decir, en descomponer una imagen en una cuadrícula de pequeños puntos llamados **píxeles**.

1. **La imagen se guarda en una matriz de píxeles:** Cada imagen está formada por una cuadrícula de pequeños puntos (píxeles). En lugar de guardar instrucciones de dibujo, se guarda información sobre el color de cada píxel.
2. **El haz de electrones sigue un orden fijo:** En lugar de moverse libremente, el haz de electrones barre la pantalla de **izquierda a derecha y de arriba a abajo**, iluminando los píxeles según la imagen almacenada en la memoria.
3. **La información de la imagen está en un **frame buffer**:** Una memoria especial almacena los valores de cada píxel (si está encendido o apagado en blanco y negro, o su color en pantallas a color).

📌 **Ejemplo:** La televisión en blanco y negro usaba esta tecnología. Cada píxel estaba encendido (blanco) o apagado (negro). Luego, con el color, cada píxel almacenaba más información.

# 1.7 Frame Buffer y Color Buffer

### **¿Qué es el Frame Buffer?**
Es un área de la memoria donde se almacena temporalmente la información de la imagen antes de enviarla a la pantalla. Cuantos más píxeles y más colores tenga la imagen, más espacio ocupará en el frame buffer.

### **¿Cómo se calcula el tamaño del frame buffer?**
Ejemplo: Una pantalla de **640×480 píxeles** en blanco y negro necesita **640×480 bits** de memoria (porque cada píxel es solo 1 bit: encendido o apagado).  
Si en lugar de blanco y negro queremos 256 niveles de gris (8 bits por píxel), entonces necesitamos **640×480×8 bits**.

Para calcularlo en MB:
- **Pantalla VGA (640×480) con color real (24 bits por píxel)** $640 \times 480 \times 24 \div 8 = 0.92 \text{ MB}$
- **Pantalla de 1280×1024 con color real (24 bits por píxel)** $1280 $\times 1024 \times 24 \div 8 = 3.75 \text{ MB}$

📌 **Importante:** Cuantos más bits por píxel, más colores se pueden representar, pero también más memoria se necesita.

### **¿Qué es el Color Buffer?**
Es el área donde se almacena la imagen lista para ser enviada al monitor. OpenGL usa ambos conceptos (frame buffer y color buffer) para gestionar la representación de imágenes en gráficos por computadora.

# 1.8 Terminales LED y tasas de refresco
Actualmente, las pantallas son LED, donde cada píxel tiene subpíxeles rojos, verdes y azules que se iluminan según el color deseado. Estas pantallas también pueden actualizar su imagen varias veces por segundo, lo que se mide en **hercios (Hz)**.
![[Pasted image 20250216234644.png]]
### **¿Cómo se calcula la tasa media de refresco?**
Ejemplo: Un juego tiene diferentes tasas de refresco durante 400 frames:

- 25 f/s durante 100 frames
- 50 f/s durante 100 frames
- 10 f/s durante 100 frames
- 25 f/s durante 100 frames

Total de frames = **400**  
Tiempo total = **20 segundos**  
Tasa media de refresco:
$\frac{400}{20} = 20 \text{ fps}$

📌 **Importante:** Cuanto mayor es la tasa de refresco, más fluida se ve la imagen y menor es la fatiga ocular.

# 1.9 Proceso de Rasterización
La **rasterización** es el proceso de convertir una escena tridimensional en una imagen 2D de píxeles en la pantalla.
## 1.9.1 Modo inmediato (Open GL hasta 1.2)
1. **Conversión de coordenadas:** Los objetos 3D tienen un sistema de coordenadas local. Primero se trasladan a un sistema de coordenadas global (world space).
2. **Ensamblado de vértices:** Se unen los puntos para formar caras de los objetos.
3. **Transformación en píxeles:** Se proyectan las caras sobre la pantalla, convirtiendo los vértices en píxeles.
4. **Interpolación de colores:** Se asigna un color a cada píxel para formar la imagen final.

📌 **Ejemplo:** En los videojuegos, cuando un objeto en 3D se dibuja en la pantalla, pasa por este proceso.

![[Pasted image 20250216234902.png]]
## 1.9.2 Vertex Shader y Fragment Shader
A partir de OpenGL 3.3, se introdujeron dos programas especiales para mejorar la rasterización:

1. **Vertex Shader:** Mueve los vértices de los objetos en la escena.
2. **Fragment Shader:** Se encarga de colorear los píxeles de la imagen final.

📌 **Ejemplo:** En un videojuego, el **vertex shader** puede modificar la posición de un personaje en función de la animación, mientras que el **fragment shader** ajusta la iluminación y los colores de su textura.

![[Pasted image 20250216235210.png]]

# 1.10 Conceptos generales de COGA

## 1.10.1 Double Buffering (Doble Búfer)
El **double buffering** es una técnica utilizada en gráficos por computadora para evitar parpadeos y mejorar la fluidez de las imágenes. Funciona con dos búferes de imágenes:

1. **Búfer primario:** Es el que se muestra en pantalla.
2. **Búfer secundario:** Es donde se dibuja la siguiente imagen.

El proceso es el siguiente:
- Mientras el usuario ve la imagen en el **búfer primario**, el sistema renderiza la siguiente imagen en el **búfer secundario**.
- Cuando la nueva imagen está lista, se intercambian los búferes (**swap**), de modo que el búfer secundario pasa a ser el primario y se muestra en pantalla.
- Este intercambio es casi instantáneo, por lo que el usuario no percibe el cambio.

Si un videojuego se ralentiza, significa que la renderización en el **búfer secundario** está tardando demasiado. Para acelerar el proceso, se pueden reducir la calidad de las texturas o la resolución.

El uso de doble búfer implica que se necesita el doble de memoria para almacenar imágenes. Por ejemplo, si antes se usaban **0,92 MB** de memoria para un solo búfer, con doble búfer se necesitan **0,92 MB × 2 = 1,84 MB**.

![[Pasted image 20250216235842.png]]

## 1.10.2 Depth Buffer (Z-Buffer o Búfer de Profundidad)
El **búfer de profundidad** resuelve el problema de qué objetos deben ser visibles cuando hay elementos que se superponen.
#### **Problema inicial: Algoritmo del pintor**

- Antes se usaba el **algoritmo del pintor**, que simplemente dibujaba los objetos en el orden en que llegaban.
- Esto fallaba cuando dos objetos se cruzaban o intersecaban, porque el orden de dibujo podía ocultar partes incorrectamente.
#### **Solución: Z-Buffer**
- Cada píxel en pantalla tiene **coordenadas (x, y)**, pero el **z-buffer** añade también la coordenada **z** (profundidad).
- Cuando se dibuja un píxel, se guarda su valor de **z** en el **búfer de profundidad**.
- Si otro objeto intenta dibujar un píxel en la misma posición **(x, y)** pero con un **z mayor** (más lejos), el píxel no se sobrescribe.
- Solo se dibujan los píxeles con el **menor valor de z** (más cercanos al observador).

El **búfer de profundidad** usa normalmente **24 bits** por píxel, aunque puede tener **8, 16 o 32 bits** según la precisión necesaria.

![[Pasted image 20250216235859.png]]

