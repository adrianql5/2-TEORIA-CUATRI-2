# 1.1 Historia de la Computaci칩n Gr치fica
La computaci칩n gr치fica surge con la necesidad de generar una salida visual en los ordenadores, lo que llev칩 al desarrollo de las primeras pantallas.

#### **A침os 50: Los inicios**
En esta d칠cada se incorporan los tubos de rayos cat칩dicos (TRC), utilizados en las primeras televisiones y monitores, conocidos popularmente como "pantallas con culo".  
Uno de los primeros dispositivos de interacci칩n fueron los sistemas de radar, empleados en control a칠reo. Estos sistemas, operados manualmente, resultaban tan deficientes que provocaban fatiga visual en los usuarios.  
En 1956 surge el **Sensorama**, considerado la primera aplicaci칩n de realidad virtual.  
Dos a침os despu칠s, en 1958, se desarrolla el primer videojuego: _Tennis for Two_.

#### **A침os 60: Primeros avances**
Durante esta d칠cada aparecen los primeros videojuegos, los sistemas CAD/CAM, el rat칩n con rueda (aunque no 칩ptico), el DVST y los primeros cascos de visi칩n estereosc칩pica.  
Uno de los nombres clave de este per칤odo es **Ivan Sutherland**, considerado el padre de la computaci칩n gr치fica moderna, por sus contribuciones tanto en hardware como en software.

#### **A침os 70: Computadores personales y videojuegos**
Nacen los primeros ordenadores personales y surgen grandes empresas de software y videojuegos como **Apple, Microsoft, Atari (1972, fundada por Nolan Bushnell y Ted Dabney) y Lucasfilm Games (1979)**.  
En 1972 se lanza la **Magnavox Odyssey**, la primera videoconsola dom칠stica.

#### **A침os 80: El concepto de escritorio y la revoluci칩n gr치fica**
En esta d칠cada surgen avances clave como:
- La introducci칩n del **concepto de escritorio (desktop)**.
- El desarrollo de los primeros **guantes de realidad virtual**.
- La tecnolog칤a **BitMap**, que m치s tarde impulsar칤a el desarrollo de la **GameBoy** y las tarjetas gr치ficas.
- Los primeros **efectos especiales en el cine**: _Tron_ (1982) y _Willow_ (1988), que us칩 por primera vez la t칠cnica de morphing.
- La expansi칩n de **Nintendo** en la industria del entretenimiento.

#### **A침os 90: OpenGL y el auge de las tarjetas gr치ficas**
- En 1992 se lanza la primera versi칩n de **OpenGL**, creada por **SGI**. Esta tecnolog칤a se us칩 en pel칤culas como _Terminator 2_ y en sistemas de visualizaci칩n avanzada.
- **Nvidia** se funda en 1993, convirti칠ndose en una de las empresas l칤deres en el desarrollo de tarjetas gr치ficas.

#### **Historia de las tarjetas gr치ficas**
- **1춹 generaci칩n (1998):** Tarjetas como **TNT2 (Nvidia), Rage (ATI) y Voodoo3 (3dfx)**. Incorporan memoria propia para almacenar texturas.
- **2춹 generaci칩n (1999-2000):** Surgen las primeras **GeForce (GeForce 256, GeForce2 de Nvidia)** y nuevas tarjetas de ATI. Introducen mejoras en transformaciones de v칠rtices e iluminaci칩n.
- **3춹 generaci칩n (2001):** Se utilizan en **PlayStation 2 y Xbox**. Son programables e incluyen soporte para **vertex shaders** y primeros **pixel shaders**. DirectX 8 introduce configurabilidad a nivel de fragmentos.
- **4춹 generaci칩n (2002 en adelante):** Incorporan **fragment shaders y vertex shaders**, permitiendo programar la GPU mediante lenguajes como **C, CG (Nvidia), GLSL (OpenGL), HLSL (DirectX) y CUDA**.

# 1.2 Visi칩n Humana
Nuestros ojos captan im치genes que atraviesan la pupila y se reflejan en la retina. Luego, el cerebro las procesa.

- El cerebro humano puede procesar entre **24 y 30 im치genes por segundo (Hz)**.
- La **persistencia de la imagen** es el tiempo que una imagen queda retenida en la retina.

# 1.3 Frames por Segundo (FPS)
En computaci칩n gr치fica, la velocidad de generaci칩n de im치genes se mide en **frames por segundo (FPS)**.

- **24 FPS** es la tasa est치ndar del cine.
- Las televisiones antiguas operaban a **50 FPS en Europa y 60 FPS en Am칠rica**, debido a la frecuencia de la electricidad.
- En videojuegos, lo ideal es mantener entre **30 y 60 FPS** para una experiencia fluida.

Si un juego se ralentiza, se pueden reducir la calidad de las texturas para mejorar la velocidad de **renderizado** y aumentar los FPS.

# 1.4 Tubos de Rayos Cat칩dicos (TRC)
Los primeros monitores funcionaban con un **haz de electrones** que impactaba contra una pantalla recubierta de **f칩sforo fluorescente**, generando luz.
- La persistencia del f칩sforo determinaba la frecuencia m칤nima de refresco, generalmente **50 Hz**.
- En pantallas monocrom치ticas, se usaba un solo haz de electrones.
- Para lograr televisi칩n en color, se utilizaron **tres haces de electrones**, cada uno activando un f칩sforo de distinto color (rojo, verde y azul).

Los TRC dominaron la industria desde su invenci칩n en **1875 por Carl Ferdinand Braun** hasta su reemplazo por pantallas LCD y LED en la d칠cada del 2000.

# 1.5 Terminales Vectoriales
Estos fueron los primeros tipos de pantallas utilizadas para visualizar gr치ficos en ordenadores. Funcionaban de manera diferente a las pantallas actuales. En lugar de representar la imagen como una cuadr칤cula de p칤xeles (como hacen las pantallas modernas), los terminales vectoriales trazaban l칤neas directamente en la pantalla siguiendo coordenadas espec칤ficas.

![[Pasted image 20250216234057.png]]

Ten칤a una memoria en la que se almacenaban las instrucciones del dibujo y que se comunicaba con la pantalla y la interfaz del ordenador. El operador interact칰a con la interfaz, que se lo enviaba a la unidad de procesamiento de la terminal gr치fica, esta le indicaba las instrucciones a la memoria, d칩nde se almacenaban (principalmente movimientos) y se realizaban l칤neas por la pantalla. El correcto funcionamiento de estos terminales depende de la complejidad del dibujo
# 1.6 Terminales Raster
Aparecen en los a침os 70 y reemplazan a los terminales vectoriales. Se basan en el concepto de **rasterizaci칩n**, es decir, en descomponer una imagen en una cuadr칤cula de peque침os puntos llamados **p칤xeles**.

1. **La imagen se guarda en una matriz de p칤xeles:** Cada imagen est치 formada por una cuadr칤cula de peque침os puntos (p칤xeles). En lugar de guardar instrucciones de dibujo, se guarda informaci칩n sobre el color de cada p칤xel.
2. **El haz de electrones sigue un orden fijo:** En lugar de moverse libremente, el haz de electrones barre la pantalla de **izquierda a derecha y de arriba a abajo**, iluminando los p칤xeles seg칰n la imagen almacenada en la memoria.
3. **La informaci칩n de la imagen est치 en un **frame buffer**:** Una memoria especial almacena los valores de cada p칤xel (si est치 encendido o apagado en blanco y negro, o su color en pantallas a color).

游늷 **Ejemplo:** La televisi칩n en blanco y negro usaba esta tecnolog칤a. Cada p칤xel estaba encendido (blanco) o apagado (negro). Luego, con el color, cada p칤xel almacenaba m치s informaci칩n.

# 1.7 Frame Buffer y Color Buffer

### **쯈u칠 es el Frame Buffer?**
Es un 치rea de la memoria donde se almacena temporalmente la informaci칩n de la imagen antes de enviarla a la pantalla. Cuantos m치s p칤xeles y m치s colores tenga la imagen, m치s espacio ocupar치 en el frame buffer.

### **쮺칩mo se calcula el tama침o del frame buffer?**
Ejemplo: Una pantalla de **640칑480 p칤xeles** en blanco y negro necesita **640칑480 bits** de memoria (porque cada p칤xel es solo 1 bit: encendido o apagado).  
Si en lugar de blanco y negro queremos 256 niveles de gris (8 bits por p칤xel), entonces necesitamos **640칑480칑8 bits**.

Para calcularlo en MB:
- **Pantalla VGA (640칑480) con color real (24 bits por p칤xel)** $640 \times 480 \times 24 \div 8 = 0.92 \text{ MB}$
- **Pantalla de 1280칑1024 con color real (24 bits por p칤xel)** $1280 $\times 1024 \times 24 \div 8 = 3.75 \text{ MB}$

游늷 **Importante:** Cuantos m치s bits por p칤xel, m치s colores se pueden representar, pero tambi칠n m치s memoria se necesita.

### **쯈u칠 es el Color Buffer?**
Es el 치rea donde se almacena la imagen lista para ser enviada al monitor. OpenGL usa ambos conceptos (frame buffer y color buffer) para gestionar la representaci칩n de im치genes en gr치ficos por computadora.

# 1.8 Terminales LED y tasas de refresco
Actualmente, las pantallas son LED, donde cada p칤xel tiene subp칤xeles rojos, verdes y azules que se iluminan seg칰n el color deseado. Estas pantallas tambi칠n pueden actualizar su imagen varias veces por segundo, lo que se mide en **hercios (Hz)**.
![[Pasted image 20250216234644.png]]
### **쮺칩mo se calcula la tasa media de refresco?**
Ejemplo: Un juego tiene diferentes tasas de refresco durante 400 frames:

- 25 f/s durante 100 frames
- 50 f/s durante 100 frames
- 10 f/s durante 100 frames
- 25 f/s durante 100 frames

Total de frames = **400**  
Tiempo total = **20 segundos**  
Tasa media de refresco:
$\frac{400}{20} = 20 \text{ fps}$

游늷 **Importante:** Cuanto mayor es la tasa de refresco, m치s fluida se ve la imagen y menor es la fatiga ocular.

# 1.9 Proceso de Rasterizaci칩n
La **rasterizaci칩n** es el proceso de convertir una escena tridimensional en una imagen 2D de p칤xeles en la pantalla.
## 1.9.1 Modo inmediato (Open GL hasta 1.2)
1. **Conversi칩n de coordenadas:** Los objetos 3D tienen un sistema de coordenadas local. Primero se trasladan a un sistema de coordenadas global (world space).
2. **Ensamblado de v칠rtices:** Se unen los puntos para formar caras de los objetos.
3. **Transformaci칩n en p칤xeles:** Se proyectan las caras sobre la pantalla, convirtiendo los v칠rtices en p칤xeles.
4. **Interpolaci칩n de colores:** Se asigna un color a cada p칤xel para formar la imagen final.

游늷 **Ejemplo:** En los videojuegos, cuando un objeto en 3D se dibuja en la pantalla, pasa por este proceso.

![[Pasted image 20250216234902.png]]
## 1.9.2 Vertex Shader y Fragment Shader
A partir de OpenGL 3.3, se introdujeron dos programas especiales para mejorar la rasterizaci칩n:

1. **Vertex Shader:** Mueve los v칠rtices de los objetos en la escena.
2. **Fragment Shader:** Se encarga de colorear los p칤xeles de la imagen final.

游늷 **Ejemplo:** En un videojuego, el **vertex shader** puede modificar la posici칩n de un personaje en funci칩n de la animaci칩n, mientras que el **fragment shader** ajusta la iluminaci칩n y los colores de su textura.

![[Pasted image 20250216235210.png]]

# 1.10 Conceptos generales de COGA

## 1.10.1 Double Buffering (Doble B칰fer)
El **double buffering** es una t칠cnica utilizada en gr치ficos por computadora para evitar parpadeos y mejorar la fluidez de las im치genes. Funciona con dos b칰feres de im치genes:

1. **B칰fer primario:** Es el que se muestra en pantalla.
2. **B칰fer secundario:** Es donde se dibuja la siguiente imagen.

El proceso es el siguiente:
- Mientras el usuario ve la imagen en el **b칰fer primario**, el sistema renderiza la siguiente imagen en el **b칰fer secundario**.
- Cuando la nueva imagen est치 lista, se intercambian los b칰feres (**swap**), de modo que el b칰fer secundario pasa a ser el primario y se muestra en pantalla.
- Este intercambio es casi instant치neo, por lo que el usuario no percibe el cambio.

Si un videojuego se ralentiza, significa que la renderizaci칩n en el **b칰fer secundario** est치 tardando demasiado. Para acelerar el proceso, se pueden reducir la calidad de las texturas o la resoluci칩n.

El uso de doble b칰fer implica que se necesita el doble de memoria para almacenar im치genes. Por ejemplo, si antes se usaban **0,92 MB** de memoria para un solo b칰fer, con doble b칰fer se necesitan **0,92 MB 칑 2 = 1,84 MB**.

![[Pasted image 20250216235842.png]]

## 1.10.2 Depth Buffer (Z-Buffer o B칰fer de Profundidad)
El **b칰fer de profundidad** resuelve el problema de qu칠 objetos deben ser visibles cuando hay elementos que se superponen.
#### **Problema inicial: Algoritmo del pintor**

- Antes se usaba el **algoritmo del pintor**, que simplemente dibujaba los objetos en el orden en que llegaban.
- Esto fallaba cuando dos objetos se cruzaban o intersecaban, porque el orden de dibujo pod칤a ocultar partes incorrectamente.
#### **Soluci칩n: Z-Buffer**
- Cada p칤xel en pantalla tiene **coordenadas (x, y)**, pero el **z-buffer** a침ade tambi칠n la coordenada **z** (profundidad).
- Cuando se dibuja un p칤xel, se guarda su valor de **z** en el **b칰fer de profundidad**.
- Si otro objeto intenta dibujar un p칤xel en la misma posici칩n **(x, y)** pero con un **z mayor** (m치s lejos), el p칤xel no se sobrescribe.
- Solo se dibujan los p칤xeles con el **menor valor de z** (m치s cercanos al observador).

El **b칰fer de profundidad** usa normalmente **24 bits** por p칤xel, aunque puede tener **8, 16 o 32 bits** seg칰n la precisi칩n necesaria.

![[Pasted image 20250216235859.png]]

